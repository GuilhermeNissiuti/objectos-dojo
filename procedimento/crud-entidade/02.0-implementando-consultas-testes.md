---
layout: post-alpha
title: "Implementando Consultas: Testes"
author: "Tiago Aguiar"
user: "taguiar"
date: "2012-03-14"
published: true
partof: procedimento-crud-entidade
num: 5
---

## <a id="TOPO"> </a> Introdução
A partir do momento em que temos informações armazenadas (seja em uma agenda, CD ou Banco de Dados),
podemos consultá-las. Essas consultas podem ser feitas manualmente (buscando em uma agenda) ou por
um sistema/programa que traz as infromações para a tela de seu computador.

Nota: A interface gráfica das consultas não fazem parte do escopo deste artigo, apenas os testes.

## Antes de iniciar 
Este item exige conhecimentos sobre:

- [TDD](http://dojo.objectos.com.br/caixa/processo-00-TDD.html)
- [Mini-arquivo.xml](http://dojo.objectos.com.br/procedimento/crud-entidade/faq-03-mini-arquivos-especificos.html)
- [Package - com.google.common.base](http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/base/package-summary.html)
- Linguagem SQL

## Especificação
Imagine o seguinte cenário: Suponhamos que uma biblioteca de uma universidade já possui um banco de
dados chamado `BIBLIOTECA` com centenas de livros armazenados. Porém, a biblioteca precisa que seus 
alunos e professores consigam consultar estes livros através dos computadores para obter sua localização 
nas prateleiras desta biblioteca.

Temos a tabela `LIVRO` com as seguintes colunas no banco de dados `BIBLIOTECA`.

- Id
- Título
- Localização
- Autor Principal
- Autor Secundário
- Publicação
- Descrição Física
- Título Original
- ISBN
- Assuntos

Nota: Detalharemos estes atributos mais adiante (tipos de dados e restrições). Preocupe-se apenas
com a especificação neste momento.

### Quais campos devemos exibir?   
A princípio, o ideal seria mostrar todos os campos, mas as vezes, nem sempre é assim. Neste exemplo,
temos um campo __Título Original__, este campo não será necessário se estivermos consultando o livros
apenas no idioma português. Em contrapartida, há pessoas que querem saber o __Título Original__ do livro
para comprá-lo em outro idioma.<br>
 
Na dúvida, sempre pergunte ao seu líder de projeto!

Voltando ao nosso exemplo, listaremos apenas alguns campos:

`TITULO`: É fundamental saber o título do livro;<br>
`LOCALIZACAO`: O corredor e a prateleira;<br>
`AUTOR_PRINCIPAL`: Muitos usuários consultam livros através de autores;<br>
`PUBLICACAO`: Sabendo a data em que foi publicado, podemos escolher um outro livro mais recente;<br>
 
Note que nosso cliente apenas deseja que alunos e professores consulte os livros no intuito de localizá-los
nas prateleiras. Mas, isto não nos impede de pensar em futuras melhorias como é o caso da utilização do
__Título Original__ descrito acima.


## Implementação
Considerando que temos:

1. A Classe-Entidade. Veja como criá-la [aqui]({{ site.baseurl }}/procedimento/crud-entidade/00.0-criando-entidades-java.html)<br>
2. Todos os dados armazenados na tabela LIVRO. Veja como criá-la [aqui]({{ site.baseurl }}/procedimento/crud-entidade/00.1-criando-testando-script-flyway.html)<br>
3. O mini-arquivo.xml com estes dados. Veja como criá-lo [aqui]({{ site.baseurl }}/procedimento/crud-entidade/faq-03-mini-arquivos-especificos.html)<br>

Nota: Validaremos mais adiante se os dados no mini-arquivo são suficientes para os testes!

Siga o checklist abaixo:
<table class="table table-bordered">
 <tr>
   <td class="tac col2em">
    <a id="topo_0_0"><input type="checkbox" /></a>
   </td>
   <td>
	<a href="#0_0">Preparar o teste e suas dependências</a>  
   </td>
 </tr>
  <tr>
   <td class="tac col2em">
    <a id="topo_0_1"><input type="checkbox" /></a>
   </td>
   <td>
    <a href="#0_1">Preparar o método de consulta com ordenação</a>
   </td>
 </tr>
   <tr>
   <td class="tac col2em">
    <a id="topo_0_1"><input type="checkbox" /></a>
   </td>
   <td>
    <a href="#0_2">Preparar o método de consulta com filtro</a>
   </td>
 </tr>
</table>

### <a id="0_0"> </a>Preparar o teste e suas dependências
Crie a classe `TesteDeConsultaDeLivro` no pacote `seu-projeto.ui.api` do diretório `src/test/java/`.<br>
Exemplo: `br.com.objectos.dojo.biblioteca.ui.api`.

	public class TesteDeConsultaDeLivro {
	}
	
Defina a classe como sendo de __Teste__ e adicione o __Módulo de Teste__ (através das anotações).

	@Test
	@Guice(modules = ModuloDeTesteObjectosDojo.class)
	public class TesteDeConsultaDeLivro {
	}
	
Importante: Cada projeto utiliza diferentes módulos de teste, atente-se a isto!
	
Declare uma variável de referência para `ConsultaDeLivro`. Esta realizará nossas consultas.

	@Test
	@Guice(modules = ModuloDeTesteObjectosDojo.class)
	public class TesteDeConsultaDeLivro {
	
	  @Inject
	  private ConsultaDeLivro consulta;
	  
	}
	
Por fim, declare uma variável de referência para `DBUnit` que carrega o `DefaultDataSet` 
contendo o arquivo `.xml` (registros da tabela).

	@Inject
	private DBUnit dbUnit;
	  
	@BeforeClass
	public void prepararDBUnit() {
	  dbUnit.loadDefaultDataSet();
	}


### <a id="0_1"> </a>Preparar o método de consulta com ordenação

Com as dependências adicionadas na classe (DBUnit, TestNG), seguimos para passo __verificar os dados no arquivo.xml__.

Precisamos ter certeza que os dados mantidos no arquivo `.xml` são suficientes para realizar os testes,
isto é, se os dados não são nulos para campos definidos `NotNull`, se os dados realmente existem,
entre outros.  

	<?xml version="1.0" encoding="UTF-8"?>
	<dataset>
			 
		<BIBLIOTECA.LIVRO ID="2"
		TITULO="Scjp Sun Certified Programmer For Java 6"
		LOCALIZACAO="133" 
		AUTOR_PRINCIPAL="Bates, Bert" 
		PUBLICACAO="2008-01-01" />
		
		<BIBLIOTECA.LIVRO ID="1"
		TITULO="Java - Como Programar"
		LOCALIZACAO="123" 
		AUTOR_PRINCIPAL="Deitel" 
		PUBLICACAO="2010-01-01" />
		
	</dataset>
	
`LOCALIZACAO="133"`: A localização é dada por __corredor (1)__ seguido de __prateleira(33).__
E todos os campos são `NotNull`.
	
Crie o método de consulta com ordenação padrão por título (especificação novamente):

	public void ordenacao_padrao_por_titulo() {
	  FakeRequestWrapper wrapper = new FakeRequestWrapper();
	  
	  List<ConsultaDeLivroDTO> res = consulta.list(wrapper);
	  
	  assertThat(res.size(), equalTo(2));
	  
	  List<String> titulos = transform(res, new ToTitulo());
	  assertThat(titulos.get(0), equalTo("Java - Como Programar"));
	  assertThat(titulos.get(1), equalTo("Scjp Sun Certified Programmer For Java 6"));
	  
	  List<Integer> localizacoes = transform(res, new ToLocalizacao());
	  assertThat(localizacoes.get(0), equalTo(123));
	  assertThat(localizacoes.get(1), equalTo(133));
	  
	  List<String> autores = transform(res, new ToAutorPrincipal());
	  assertThat(autores.get(0), equalTo("Deitel"));
	  assertThat(autores.get(1), equalTo("Bates, Bert"));
	  
	  List<LocalDate> publicacoes = transform(res, new ToPublicacao());
	  assertThat(publicacoes.get(0), equalTo(new DateTime(2010, 1, 1)));
	  assertThat(publicacoes.get(1), equalTo(new DateTime(2008, 1, 1)));
	}
	
Importante: O método `transform` do `com.google.common.collect.Lists` em conjunto da interface
`Function<F,T>` do `com.google.common.base` "divide" a tabela em colunas, assim, podemos consultar 
cada campo de uma única coluna.

Implemente a interface `Function<F,T>` com classes privadas:

	private class ToTitulo implements Function<ConsultaDeLivroDTO, String> {
	  @Override
	  public String apply(ConsultaDeLivroDTO input) {
	    return input.getTitulo();
	  }
	}
	
	private class ToLocalizacao implements Function<ConsultaDeLivroDTO, Integer> {
	  @Override
	  public Integer apply(ConsultaDeLivroDTO input) {
	    return input.getLocalizacao();
	  }
	}
	
	private class ToAutorPrincipal implements Function<ConsultaDeLivroDTO, String> {
	  @Override
	  public String apply(ConsultaDeLivroDTO input) {
	    return input.getAutoPrincipal();
	  }
	}
	
	private class ToPublicacao implements Function<ConsultaDeLivroDTO, LocalDate> {
	  @Override
	  public LocalDate apply(ConsultaDeLivroDTO input) {
	    return input.getPublicacao();
	  }
	}
	
### <a id="0_2"> </a>Preparar o método de consulta com filtro
Com o filtro podemos consultar dados específicos (neste caso, pelas prateleiras).
  
    public void filtro_por_localizacao() {
      FakeRequestWrapper wrapper = new FakeRequestWrapper();
      wrapper.put("localizacao", 123);
    
      List<ConsultaDeLivroDTO> res = consulta.list(wrapper);
      assertThat(res.size(), equalTo(1));
      assertThat(res.get(0).getLocalizacacao(), equalTo(123));
    }
    
A classe de teste está concluída, mas note que há muitos erros de compilação. Estes erros ocorrem 
porque ainda não definimos as outras classes/interfaces necessárias para que o teste funcione realmente.<br> 
A classe e a interface são `ConsultaDeLivro` e `ConsultaDeLivroDTO` respectivamente.

Siga para o próximo passo. As consultas! <a href="{{ site.baseurl }}/procedimento/crud-entidade/02.1-implementando-consultas-consultas.html" class="btn btn-success">Continuar!</a><br>
Leia mais uma vez! <a href="#TOPO" class="btn btn-warning">Revisar!</a>